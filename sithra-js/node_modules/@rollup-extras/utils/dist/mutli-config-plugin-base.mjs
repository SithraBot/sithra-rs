function multiConfigPluginBase(useWriteBundle, pluginName, execute, onFinalHook) {
    const finalHook = useWriteBundle ? 'writeBundle' : 'generateBundle';
    let remainingOutputsCount = 0, configsCount = 0;
    const configs = new Set();
    const instance = {
        name: pluginName,
        renderStart,
        [finalHook]: writeBundle,
        api: { addInstance }
    };
    return instance;
    function addInstance() {
        const configId = ++configsCount;
        configs.add(configId);
        return {
            name: `${pluginName}#${configId}`,
            renderStart: () => {
                configs.delete(configId);
                return renderStart();
            },
            [finalHook]: writeBundle
        };
    }
    function renderStart() {
        ++remainingOutputsCount;
    }
    async function writeBundle(options, bundle) {
        --remainingOutputsCount;
        if (onFinalHook) {
            await onFinalHook.call(this, options, bundle, configs.size, remainingOutputsCount);
        }
        if (configs.size === 0 && remainingOutputsCount === 0) {
            // do work
            try {
                await execute.call(this, options, bundle);
            }
            finally {
                // reset configs
                for (let i = configsCount; i > 0; --i) {
                    configs.add(i);
                }
            }
        }
    }
}

export { multiConfigPluginBase };
